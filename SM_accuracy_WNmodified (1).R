#################################################################################################
#this code demonstrates the following:
#1) defining a function (called smith.martin.model) that simulates the Smith Martin DDE model
#2) defining a function (called fit.func) that takes as inputs a parameter vector (called parms)
#and a real dataset (called real.data). fit.func passes parms to smith.martin.model,
#receives a simulated dataset (called sim.data), and returns the sum of squared differences (SSD) between
#read.data and sim.data
#3) a function that takes as input a real dataset (real.data) and calls an optimising function
#(the optim function) to find a parameter vector that minimises the SSD between this dataset and 
#the simulated datasets produced by smith.martin.model

##########################################################################################################
#A simple example of how to simulate data from a DDE -- i.e. the Smith Martin model
##########################################################################################################
require(deSolve)

#this function defines the Smith Martin model
smith.martin.model <- function(t,Y,parms){
  with(as.list(c(parms,Y)), {
    if(t < deltat){
      lag1 <- init.vec[1:(ngen+1)]
    }
    else{
      lag1 <- lagvalue(t-deltat)[1:(ngen+1)]
    }
    temp <- exp(-d_0*deltat)
    dN <- rep(0,length(Y))
    dN[1] <- -(lambda_0 + d_0)*Y[1]
    dN[2] <- 2*lambda_0*temp*lag1[1] - (lambda+d)*Y[2]
    dN[3:(ngen+1)] <- 2*lambda*temp*lag1[2:ngen] - (lambda+d)*Y[3:(ngen+1)]
    
    dN[ngen+2] <- -lambda_0*temp*lag1[1] - d_0*Y[ngen+2]
    dN[ngen+3] <- 2*lambda_0*temp*lag1[1] - lambda*temp*lag1[2] - d*Y[ngen+3]
    dN[(ngen+4):(2*ngen+2)] <- 2*lambda*temp*lag1[2:ngen] - lambda*temp*lag1[3:(ngen+1)] - d*Y[(ngen+4):(2*ngen+2)]
    list(dN)
  })
}

#this function that takes as inputs a parameter vector (called parms)
#and a real dataset (called real.data). It passes parms to smith.martin.model,
#receives a simulated dataset (called sim.data), and returns the SSD between
#the real and simulated datasets
fit.func <- function(parms,real.data){
  #generated simulated data
  sim.data <- dede(init.vec,t_pts,smith.martin.model,parms)
  #put sim.data in the same form as real.data
  sim.data <- sim.data[,(ngen+3):(2*ngen+3)]
  #return SSD between sim.data and real.data
  return (sum((real.data - sim.data)^2))
}

#this function takes as input a real dataset (real.data) and calls an optimising function
#(R's optim function) to find a parameter vector that minimises the SSD between this dataset and 
#simulated datasets produced by smith.martin.model
optim.func <- function(real.data){
  #generate new parameter vector
  lb <- rep(1e-3,5) #lower-bound of paramter values
  ub <- c(rep(1,4),100) #upper-bound of parameter values
  parms <- runif(5,min=lb,max=ub) #new random parameter vector
  names(parms) <- c('lambda_0', 'lambda', 'd_0', 'd', 'deltat') #names of the parameters
  opt.parms <- optim(parms, fit.func, gr=NULL, real.data, lower=lb, upper=ub)
  return (c(opt.parms$value,opt.parms$par))
}

#define parameters of the model
#maximum number of division classes to be considered
ngen <- 20
#vector giving number of cells in each division class
init.vec <- rep(0,2*ngen+2)
#number of cells in A phase in i'th generation is denoted NAi
#total number of cells in i'th generation is denoted Ni
names(init.vec) <- paste(rep(c('NA','N'),each=ngen+1),0:ngen,sep='')
#start with 50,000 cells in 0'th generation
init.vec[c('NA0','N0')] <- 5e4
#set the time points at which data should be simulated
#these correspond to the time points in the real dataset
t_pts <- seq(0,120,12)
###################################################


#read "real" dataset into the computer's memory and the re-shape it
#so that column j contains the total number of cells that have divided (j-1) times
#while row i contains cells found at the i'th time point
sum.cols <- function(idx, data) return (rowSums(data[,idx]))
raw.data <- read.table("~/Dropbox/Data/datasets/agent_based_sim_output_3.txt",header = TRUE)
real.data <- matrix(rep(0, (length(t_pts)*(ngen+1))), nrow = length(t_pts))
real.data[1,1] <- init.vec[1]
real.data[-1,] <- aa <- sapply(split(2:43,rep(1:21,each=2)),sum.cols,raw.data)

#now, find parameters that minimise the SSD between real.data and corresponding simulated datasets
#generated by the Smith Martin model
opt.parms <- optim.func(real.data)

#the first entry of opt.parms is the SSD while the remaining entries are the corresponding parameter values
#A single run of R's optim function typically does not produce the best possible results. It is therefore
#advisable call run optim.func many times and choose the parameter values with the lowest SSD.
#Below, I call optim.func 10 times and choose the best parameter values
opt.parms2 <- mapply(optim.func, rep(list(real.data),2))
best.parms <- opt.parms2[,which.min(opt.parms2[1,])]
best.parms